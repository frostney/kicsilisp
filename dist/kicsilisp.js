// Generated by CoffeeScript 1.6.3
(function() {
  (function(root) {
    var Context, categorize, execute, interpret, interpretList, parenthesize, parse, special, stdLibrary, tokenize;
    stdLibrary = {
      first: function(x) {
        return x[0];
      },
      rest: function(x) {
        return x.slice(1);
      },
      print: function() {
        return console.log.apply(null, arguments);
      }
    };
    Context = (function() {
      function Context(scope, parent) {
        this.scope = scope;
        this.parent = parent;
      }

      Context.prototype.get = function(ident) {
        var _ref;
        return (_ref = this.scope[ident]) != null ? _ref : (this.parent != null ? this.parent.get(ident) : void 0);
      };

      return Context;

    })();
    special = {
      "let": function(input, context) {
        var letContext;
        letContext = input[1].reduce((function(acc, x) {
          acc.scope[x[0].value] = interpret(x[1], context);
          return acc;
        }), new Context({}, context));
        return interpret(input[2], letContext);
      },
      lambda: function(input, context) {
        return function() {
          var lambaArguments, lambaScope;
          lambaArguments = arguments;
          lambaScope = input[1].reduce((function(acc, x, i) {
            acc[x.value] = lambdaArguments[i];
            return acc;
          }), {});
          return interpret(input[2], new Context(lambdaScope, context));
        };
      },
      "if": function(input, context) {
        if (interpret(input[1], context)) {
          return interpret(input[2], context);
        } else {
          return interpret(input[3], context);
        }
      }
    };
    interpretList = function(input, context) {
      var list;
      if (special.hasOwnProperty(input[0].value)) {
        return special[input[0].value](input, context);
      } else {
        list = input.map(function(x) {
          return interpret(x, context);
        });
        if (list[0] instanceof Function) {
          return list[0].apply(null, list.slice(1));
        } else {
          return list;
        }
      }
    };
    interpret = function(input, context) {
      if (context == null) {
        return interpret(input, new Context(stdLibrary));
      } else {
        if (input instanceof Array) {
          return interpretList(input, context);
        } else {
          if (input.type === 'identifier') {
            return context.get(input.value);
          } else {
            return input.value;
          }
        }
      }
    };
    categorize = function(input) {
      if (!isNaN(parseFloat(input))) {
        return {
          type: 'literal',
          value: parseFloat(input)
        };
      } else {
        if (input[0] === '"' && input.slice(-1) === '"') {
          return {
            type: 'literal',
            value: input.slice(1, -1)
          };
        } else {
          return {
            type: 'identifier',
            value: input
          };
        }
      }
    };
    parenthesize = function(input, list) {
      var token;
      if (list == null) {
        return parenthesize(input, []);
      } else {
        token = input.shift();
        if (token == null) {
          return list.pop();
        } else {
          if (token === '(') {
            list.push(parenthesize(input, []));
            return parenthesize(input, list);
          } else {
            if (token === ')') {
              return list;
            } else {
              return parenthesize(input, list.concat(categorize(token)));
            }
          }
        }
      }
    };
    tokenize = function(input) {
      return input.split('"').map((function(x, i) {
        if (i % 2 === 0) {
          return x.replace(/\(/g, ' ( ').replace(/\)/g, ' ) ');
        } else {
          return x.replace(/\s/g, "!whitespace!");
        }
      })).join('"').trim().split(/\s+/).map(function(x) {
        return x.replace(/!whitespace!/g, " ");
      });
    };
    parse = function(input) {
      return parenthesize(tokenize(input));
    };
    execute = function(input) {
      return interpret(parse(input));
    };
    return root.kicsiLisp = {
      parse: parse,
      interpret: interpret,
      execute: execute
    };
  })(typeof exports !== "undefined" && exports !== null ? exports : this);

}).call(this);
